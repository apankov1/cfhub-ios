//
// Action.swift
// CFHub iOS
//
// ðŸ¤– Generated with [Claude Code](https://claude.ai/code)
// Co-Authored-By: Claude <noreply@anthropic.com>
//

import Foundation

/// Actions represent planned changes to infrastructure resources
///
/// Following the cloudflare-hub pattern, actions are generated by comparing
/// current state with desired state, then executed by integrations.
public struct Action: Sendable, Codable, Identifiable {
    public let id: String
    public let type: ActionType
    public let resourceId: String
    public let resourceType: ResourceType
    public let operation: ActionOperation
    public let parameters: ActionParameters
    public let dependencies: [String]
    public let estimatedDuration: TimeInterval?
    public let createdAt: Date

    public init(
        id: String = UUID().uuidString,
        type: ActionType,
        resourceId: String,
        resourceType: ResourceType,
        operation: ActionOperation,
        parameters: ActionParameters = ActionParameters(),
        dependencies: [String] = [],
        estimatedDuration: TimeInterval? = nil,
        createdAt: Date = Date()
    ) {
        self.id = id
        self.type = type
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.operation = operation
        self.parameters = parameters
        self.dependencies = dependencies
        self.estimatedDuration = estimatedDuration
        self.createdAt = createdAt
    }
}

/// Types of actions that can be performed
public enum ActionType: String, Sendable, Codable, CaseIterable {
    case create
    case update
    case delete
    case deploy
    case rollback
    case scale
    case restart
    case pause
    case resume
    case migrate
    case backup
    case restore

    public var isDestructive: Bool {
        switch self {
        case .delete, .rollback, .migrate, .restore:
            return true
        case .create, .update, .deploy, .scale, .restart, .pause, .resume, .backup:
            return false
        }
    }

    public var requiresConfirmation: Bool {
        switch self {
        case .delete, .rollback, .migrate, .restore, .pause:
            return true
        case .create, .update, .deploy, .scale, .restart, .resume, .backup:
            return false
        }
    }
}

/// Specific operations within each action type
public enum ActionOperation: Sendable, Codable {
    // Create operations
    case createResource(configuration: ResourceConfiguration)
    case createEnvironment(name: String, branch: String)
    case createDeployment(commit: String, environment: String)

    // Update operations
    case updateConfiguration(changes: ResourceConfiguration)
    case updateEnvironmentVariables([String: String])
    case updateDNSRecords([DNSRecord])

    // Delete operations
    case deleteResource
    case deleteEnvironment
    case deleteDeployment

    // Deploy operations
    case deployCode(source: DeploymentSource)
    case deployConfiguration(ResourceConfiguration)
    case deployToEnvironment(environment: String)

    // Scale operations
    case scaleUp(instances: Int)
    case scaleDown(instances: Int)
    case autoScale(min: Int, max: Int)

    // Control operations
    case start
    case stop
    case restart
    case pause
    case resume

    // Data operations
    case backup(destination: String)
    case restore(source: String)
    case migrate(destination: String)

    // Rollback operations
    case rollbackToVersion(version: String)
    case rollbackToCommit(commit: String)
    case rollbackDeployment(deploymentId: String)

    public var displayName: String {
        switch self {
        case .createResource:
            return "Create Resource"
        case .createEnvironment:
            return "Create Environment"
        case .createDeployment:
            return "Create Deployment"
        case .updateConfiguration:
            return "Update Configuration"
        case .updateEnvironmentVariables:
            return "Update Environment Variables"
        case .updateDNSRecords:
            return "Update DNS Records"
        case .deleteResource:
            return "Delete Resource"
        case .deleteEnvironment:
            return "Delete Environment"
        case .deleteDeployment:
            return "Delete Deployment"
        case .deployCode:
            return "Deploy Code"
        case .deployConfiguration:
            return "Deploy Configuration"
        case .deployToEnvironment:
            return "Deploy to Environment"
        case .scaleUp:
            return "Scale Up"
        case .scaleDown:
            return "Scale Down"
        case .autoScale:
            return "Auto Scale"
        case .start:
            return "Start"
        case .stop:
            return "Stop"
        case .restart:
            return "Restart"
        case .pause:
            return "Pause"
        case .resume:
            return "Resume"
        case .backup:
            return "Backup"
        case .restore:
            return "Restore"
        case .migrate:
            return "Migrate"
        case .rollbackToVersion:
            return "Rollback to Version"
        case .rollbackToCommit:
            return "Rollback to Commit"
        case .rollbackDeployment:
            return "Rollback Deployment"
        }
    }
}

/// Flexible parameters for actions
public struct ActionParameters: Sendable, Codable {
    private let storage: [String: ParameterValue]

    public init(_ dictionary: [String: ParameterValue] = [:]) {
        self.storage = dictionary
    }

    public func value<T: Codable>(for key: String, as type: T.Type) -> T? {
        storage[key]?.value as? T
    }

    public mutating func setValue<T: Codable & Sendable>(_ value: T?, for key: String) {
        var mutableStorage = storage
        if let value = value {
            mutableStorage[key] = ParameterValue(value)
        } else {
            mutableStorage.removeValue(forKey: key)
        }
        self = ActionParameters(mutableStorage)
    }

    public var keys: [String] {
        Array(storage.keys)
    }
}

/// Type-erased parameter value
public struct ParameterValue: Sendable, Codable {
    public let value: any Codable & Sendable
    private let typeIdentifier: String

    public init<T: Codable & Sendable>(_ value: T) {
        self.value = value
        self.typeIdentifier = String(describing: T.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()

        switch value {
        case let string as String:
            try container.encode(string)
        case let int as Int:
            try container.encode(int)
        case let double as Double:
            try container.encode(double)
        case let bool as Bool:
            try container.encode(bool)
        case let array as [String]:
            try container.encode(array)
        case let dict as [String: String]:
            try container.encode(dict)
        default:
            throw EncodingError.invalidValue(
                value,
                EncodingError.Context(
                    codingPath: encoder.codingPath,
                    debugDescription: "Unsupported parameter value type: \(typeIdentifier)"
                )
            )
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        if let string = try? container.decode(String.self) {
            self.value = string
            self.typeIdentifier = "String"
        } else if let int = try? container.decode(Int.self) {
            self.value = int
            self.typeIdentifier = "Int"
        } else if let double = try? container.decode(Double.self) {
            self.value = double
            self.typeIdentifier = "Double"
        } else if let bool = try? container.decode(Bool.self) {
            self.value = bool
            self.typeIdentifier = "Bool"
        } else if let array = try? container.decode([String].self) {
            self.value = array
            self.typeIdentifier = "[String]"
        } else if let dict = try? container.decode([String: String].self) {
            self.value = dict
            self.typeIdentifier = "[String: String]"
        } else {
            throw DecodingError.typeMismatch(
                ParameterValue.self,
                DecodingError.Context(
                    codingPath: decoder.codingPath,
                    debugDescription: "Could not decode parameter value"
                )
            )
        }
    }
}

/// DNS record for DNS operations
public struct DNSRecord: Sendable, Codable {
    public let type: DNSRecordType
    public let name: String
    public let content: String
    public let ttl: Int?
    public let priority: Int?

    public init(
        type: DNSRecordType,
        name: String,
        content: String,
        ttl: Int? = nil,
        priority: Int? = nil
    ) {
        self.type = type
        self.name = name
        self.content = content
        self.ttl = ttl
        self.priority = priority
    }
}

/// DNS record types
public enum DNSRecordType: String, Sendable, Codable, CaseIterable {
    case aRecord = "A"
    case aaaa = "AAAA"
    case cname = "CNAME"
    case mx = "MX"
    case txt = "TXT"
    case srv = "SRV"
    case ptr = "PTR"
    case ns = "NS"
    case soa = "SOA"
}

/// Deployment source options
public enum DeploymentSource: Sendable, Codable {
    case git(repository: String, branch: String, commit: String?)
    case archive(url: String)
    case local(path: String)
    case artifact(id: String)

    public var displayName: String {
        switch self {
        case let .git(repository, branch, _):
            return "\(repository)@\(branch)"
        case let .archive(url):
            return "Archive: \(url)"
        case let .local(path):
            return "Local: \(path)"
        case let .artifact(id):
            return "Artifact: \(id)"
        }
    }
}
